<?php

namespace Emkcloud\IseriesDb2\Schema;

use Emkcloud\IseriesDb2\Enums\IseriesDb2TypesKeys;
use Emkcloud\IseriesDb2\Query\IseriesDb2SQLCompile;
use Emkcloud\IseriesDb2\Traits\IseriesDb2Common;
use Exception;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Schema\Grammars\Grammar;
use Illuminate\Support\Fluent;
use Illuminate\Support\Str;
use RuntimeException;

class IseriesDb2SchemaGrammar extends Grammar
{
    use IseriesDb2Common;

    /**
     * Get the target database schema.
     */
    protected function getSchema($schema = null)
    {
        return $schema
            ?: $this->connection->getConfig('schema')
            ?: $this->connection->getDatabaseName();
    }

    /**
     * Get the target database schema.
     */
    protected function getDefaultConstant(Fluent $column)
    {
        return (isset($column->autoIncrement) && $column->autoIncrement) ? '' : ' DEFAULT';
    }

    /**
     * Check syntax for current date fields.
     */
    protected function checkCurrentDate(Fluent $column)
    {
        if (isset($column->useCurrent) && $column->useCurrent)
        {
            return ' DEFAULT CURRENT_DATE';
        }
    }

    /**
     * Check syntax for current time fields.
     */
    protected function checkCurrentTime(Fluent $column)
    {
        if (isset($column->useCurrent) && $column->useCurrent)
        {
            return ' DEFAULT CURRENT_TIME';
        }
    }

    /**
     * Check syntax for current timestamp fields.
     */
    protected function checkCurrentTimestamp(Fluent $column)
    {
        if (isset($column->useCurrent) && $column->useCurrent)
        {
            return ' DEFAULT CURRENT_TIMESTAMP';
        }
    }

    /**
     * Check options for a binary type column.
     */
    protected function checkFieldBinary(Fluent $column)
    {
        return $this->checkFieldBinaryDefault($column).
               $this->checkFieldBinaryNullable($column);
    }

    /**
     * Check option default for a string type column.
     */
    protected function checkFieldBinaryDefault(Fluent $column)
    {
        if (isset($column->default) && $column->default)
        {
            return " DEFAULT $column->default";
        }

        return $this->getDefaultConstant($column);
    }

    /**
     * Check option nullable for a string type column.
     */
    protected function checkFieldBinaryNullable(Fluent $column)
    {
        return $this->checkFieldNullable($column);
    }

    /**
     * Check options for a string type column.
     */
    protected function checkFieldString(Fluent $column)
    {
        return $this->checkFieldStringDefault($column).
               $this->checkFieldStringNullable($column);
    }

    /**
     * Check option default for a string type column.
     */
    protected function checkFieldStringDefault(Fluent $column)
    {
        if (isset($column->default) && $column->default)
        {
            return " DEFAULT '$column->default'";
        }

        return $this->getDefaultConstant($column);
    }

    /**
     * Check option nullable for a string type column.
     */
    protected function checkFieldStringNullable(Fluent $column)
    {
        return $this->checkFieldNullable($column);
    }

    /**
     * Check options for a numeric type column.
     */
    protected function checkFieldNumeric(Fluent $column)
    {
        return $this->checkFieldNumericDefault($column).
               $this->checkFieldNumericNullable($column).
               $this->checkFieldNumericUnsigned($column);
    }

    /**
     * Check default for a numeric type column.
     */
    protected function checkFieldNumericDefault(Fluent $column)
    {
        if (isset($column->default) && $column->default)
        {
            return " DEFAULT $column->default";
        }

        return $this->getDefaultConstant($column);
    }

    /**
     * Check nullable for a numeric type column.
     */
    protected function checkFieldNumericNullable(Fluent $column)
    {
        return $this->checkFieldNullable($column);
    }

    /**
     * Check unsigned for a numeric type column.
     */
    protected function checkFieldNumericUnsigned(Fluent $column)
    {
        if (isset($column->autoIncrement) && $column->autoIncrement)
        {
            return ' GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1)';
        }

        return ($column->unsigned ?? false) ? ' CHECK ('.$column['name'].' >= 0)' : '';
    }

    /**
     * Check nullable for a generic type column.
     */
    protected function checkFieldNullable(Fluent $column)
    {
        if (isset($column->autoIncrement) && $column->autoIncrement)
        {
            return '';
        }

        return ($column->nullable ?? false) ? '' : ' NOT NULL';
    }

    /**
     * Compile an add column command.
     */
    public function compileAdd(Blueprint $blueprint, Fluent $command)
    {
        return sprintf('ALTER table %s ADD %s',
            $this->wrapTable($blueprint),
            $this->getColumn($blueprint, $command->column)
        );
    }

    /**
     * Compile the query to determine the columns.
     */
    public function compileColumns($schema, $table)
    {
        return sprintf(IseriesDb2SQLCompile::compileColumns(),
            $this->quoteString($this->getSchema($schema)),
            $this->quoteString($table)
        );
    }

    /**
     * Compile a create table command.
     */
    public function compileCreate(IseriesDb2Blueprint $blueprint, Fluent $command)
    {
        $tabname = $this->wrapTable($blueprint);
        $columns = $this->getColumns($blueprint);

        if ($blueprint->getSystemName() && $this->isNotValidAs400ObjectName($tabname))
        {
            return sprintf(IseriesDb2SQLCompile::compileCreateWithSystemName(),
                Str::upper($tabname), $blueprint->getSystemName(), implode(', ', $columns)
            );
        }

        return sprintf(IseriesDb2SQLCompile::compileCreate(),
            Str::upper($tabname), implode(', ', $columns)
        );
    }

    /**
     * Compile a change column command into a series of SQL statements.
     */
    public function compileChange(Blueprint $blueprint, Fluent $command)
    {
        throw new RuntimeException('This database driver does not support modifying columns.');
    }

    /**
     * Compile a drop column command.
     */
    public function compileDropColumn(IseriesDb2Blueprint $blueprint, Fluent $command)
    {
        $columns = $this->prefixArray('DROP COLUMN', $this->wrapArray($command->columns));

        return 'ALTER TABLE '.$this->wrapTable($blueprint).' '.implode(' ', $columns);
    }

    /**
     * Compile a drop fulltext index command.
     */
    public function compileDropFullText(Blueprint $blueprint, Fluent $command)
    {
        throw new RuntimeException('This database driver does not support fulltext index removal.');
    }

    /**
     * Compile a drop table (if exists) command.
     */
    public function compileDropIfExists(IseriesDb2Blueprint $blueprint, Fluent $command)
    {
        return sprintf(IseriesDb2SQLCompile::compileDropIfExists(),
            $this->wrapTable($blueprint)
        );
    }

    /**
     * Compile a drop index command.
     */
    public function compileDropIndex(IseriesDb2Blueprint $blueprint, Fluent $command)
    {
        $table = $this->wrapTable($blueprint);

        return sprintf(IseriesDb2SQLCompile::compileDropIndex(),
            $this->removeSchemaFromIndexName($table, $command->index)
        );
    }

    /**
     * Compile a drop unique command.
     */
    public function compileDropPrimary(IseriesDb2Blueprint $blueprint, Fluent $command)
    {
        return sprintf(IseriesDb2SQLCompile::compileDropPrimary(),
            $this->wrapTable($blueprint)
        );
    }

    /**
     * Compile a drop spatial index command.
     */
    public function compileDropSpatialIndex(Blueprint $blueprint, Fluent $command)
    {
        throw new RuntimeException('This database driver does not support spatial index removal.');
    }

    /**
     * Compile a drop unique command.
     */
    public function compileDropUnique(IseriesDb2Blueprint $blueprint, Fluent $command)
    {
        return $this->compileDropIndex($blueprint, $command);
    }

    /**
     * Compile a executeCommand command.
     */
    private function compileExecuteCommand($command)
    {
        return "CALL QSYS2.QCMDEXC('".$command."')";
    }

    /**
     * Compile the query to determine the foreign keys.
     */
    public function compileForeignKeys($schema, $table)
    {
        return sprintf(IseriesDb2SQLCompile::compileForeignKeys(),
            $this->quoteString($this->getSchema($schema)),
            $this->quoteString($table),
            $this->quoteString(IseriesDb2TypesKeys::FOREIGN)
        );
    }

    /**
     * Compile a fulltext index key command.
     */
    public function compileFulltext(Blueprint $blueprint, Fluent $command)
    {
        throw new RuntimeException('This database driver does not support fulltext index creation.');
    }

    /**
     * Compile a plain index key command.
     */
    public function compileIndex(IseriesDb2Blueprint $blueprint, Fluent $command)
    {
        $table = $this->wrapTable($blueprint);

        $indexname = $this->removeSchemaFromIndexName($table, $command->index);

        return sprintf(IseriesDb2SQLCompile::compileIndex(),
            $indexname, $table, $this->columnize($command->columns)
        );
    }

    /**
     * Compile the query to determine the indexes.
     */
    public function compileIndexes($schema, $table)
    {
        $this->setCurrentSchemaAndTable($this->getSchema($schema), $table);

        return sprintf(IseriesDb2SQLCompile::compileIndexes(),
            $this->quoteString($this->getCurrentSchema()),
            $this->quoteString($this->getCurrentTable())
        );
    }

    /**
     * Compile a primary key command.
     */
    public function compilePrimary(IseriesDb2Blueprint $blueprint, Fluent $command)
    {
        return sprintf(IseriesDb2SQLCompile::compilePrimary(),
            $this->wrapTable($blueprint),
            $this->columnize($command->columns)
        );
    }

    /**
     * Compile an ReplyListEntryAdd command.
     */
    public function compileReplyListEntryAdd(IseriesDb2Blueprint $blueprint, Fluent $command)
    {
        $sequence = $blueprint->getReplyListEntrySequence();

        $this->compileReplyListEntryAddSafe($sequence);

        return $this->compileExecuteCommand("ADDRPYLE SEQNBR($sequence) MSGID(CPA32B2) RPY(''I'')");
    }

    /**
     * Remove the entry before running ADDRPYLE to avoid SQL exceptions.
     */
    private function compileReplyListEntryAddSafe($sequence)
    {
        try
        {
            $this->connection->statement("CALL QSYS2.QCMDEXC('RMVRPYLE SEQNBR($sequence)')");

        } catch (Exception $e)
        {
        }
    }

    /**
     * Compile an ReplyListEntryJob command.
     */
    public function compileReplyListEntryJob(IseriesDb2Blueprint $blueprint, Fluent $command)
    {
        return $this->compileExecuteCommand('CHGJOB INQMSGRPY(*SYSRPYL)');
    }

    /**
     * Compile an ReplyListEntryRemove command.
     */
    public function compileReplyListEntryRemove(IseriesDb2Blueprint $blueprint, Fluent $command)
    {
        $sequence = $blueprint->getReplyListEntrySequence();

        return $this->compileExecuteCommand("RMVRPYLE SEQNBR($sequence)");
    }

    /**
     * Compile a spatial index key command.
     */
    public function compileSpatialIndex(Blueprint $blueprint, Fluent $command)
    {
        throw new RuntimeException('This database driver does not support spatial index creation.');
    }

    /**
     * Compile the query to determine the tables.
     */
    public function compileTables($schema)
    {
        $engine = $this->connection->getPdo()->getAttribute(\PDO::ATTR_SERVER_INFO);

        return sprintf(IseriesDb2SQLCompile::compileTables(),
            $this->quoteString($engine),
            $this->quoteString($this->getSchema($schema))
        );
    }

    /**
     * Compile the query to determine if the given table exists.
     */
    public function compileTableExists($schema, $table)
    {
        return sprintf(IseriesDb2SQLCompile::compileTableExists(),
            $this->quoteString($this->getSchema($schema)),
            $this->quoteString($table)
        );
    }

    /**
     * Compile a unique key command.
     */
    public function compileUnique(IseriesDb2Blueprint $blueprint, Fluent $command)
    {
        $table = $this->wrapTable($blueprint);

        $indexname = $this->removeSchemaFromIndexName($table, $command->index);

        return sprintf(IseriesDb2SQLCompile::compileUnique(),
            $indexname, $table, $this->columnize($command->columns)
        );

        $table = $this->wrapTable($blueprint);

        return sprintf(IseriesDb2SQLCompile::compileUnique(), $table,
            $this->removeSchemaFromIndexName($table, $command->index),
            $this->columnize($command->columns)
        );
    }

    /**
     * Compile the query to determine the views.
     */
    public function compileViews($schema)
    {
        return sprintf(IseriesDb2SQLCompile::compileViews(),
            $this->quoteString($this->getSchema($schema))
        );
    }

    /**
     * Create the column definition for a binary type.
     */
    protected function typeBinary(Fluent $column)
    {
        if (isset($column->length) && $column->length)
        {
            return (isset($column->fixed) && $column->fixed)
                ? "BINARY($column->length)".$this->checkFieldBinary($column)
                : "VARBINARY($column->length)".$this->checkFieldBinary($column);
        }

        return 'BLOB'.$this->checkFieldBinary($column);
    }

    /**
     * Create the column definition for a boolean type.
     */
    protected function typeBoolean(Fluent $column)
    {
        $statement = sprintf('SMALLINT CONSTRAINT %s_%s CHECK(%s IN(0, 1))',
            $column->type, $column->name, $column->name);

        return $statement.$this->checkFieldNumeric($column);
    }

    /**
     * Create the column definition for a big integer type.
     */
    protected function typeBigInteger(Fluent $column)
    {
        return 'BIGINT'.$this->checkFieldNumeric($column);
    }

    /**
     * Create the column definition for a char type.
     */
    protected function typeChar(Fluent $column)
    {
        return "CHAR({$column->length})".$this->checkFieldString($column);
    }

    /**
     * Create the column definition for a date type.
     */
    protected function typeDate(Fluent $column)
    {
        return 'DATE'.$this->checkFieldNullable($column).$this->checkCurrentDate($column);
    }

    /**
     * Create the column definition for a datetime type.
     */
    protected function typeDateTime(Fluent $column)
    {
        return $this->typeTimestamp($column);
    }

    /**
     * Create the column definition for a datetimeTz type.
     */
    protected function typeDateTimeTz(Fluent $column)
    {
        return $this->typeDateTime($column);
    }

    /**
     * Create the column definition for a decimal type.
     */
    protected function typeDecimal(Fluent $column)
    {
        return "DECIMAL({$column->total}, {$column->places})".$this->checkFieldNumeric($column);
    }

    /**
     * Create the column definition for a double type.
     */
    protected function typeDouble(Fluent $column)
    {
        return 'DOUBLE'.$this->checkFieldNumeric($column);
    }

    /**
     * Create the column definition for a enumeration type.
     */
    protected function typeEnum(Fluent $column)
    {
        throw new RuntimeException('This database driver does not support the enumeration type.');
    }

    /**
     * Create the column definition for a float type.
     */
    protected function typeFloat(Fluent $column)
    {
        return "FLOAT({$column->precision})".$this->checkFieldNumeric($column);
    }

    /**
     * Create the column definition for a geography type.
     */
    protected function typeGeography(Fluent $column)
    {
        throw new RuntimeException('This database driver does not support the geography type.');
    }

    /**
     * Create the column definition for a geometry type.
     */
    protected function typeGeometry(Fluent $column)
    {
        throw new RuntimeException('This database driver does not support the geometry type.');
    }

    /**
     * Create the column definition for an IP address type.
     */
    protected function typeIpAddress(Fluent $column)
    {
        return 'VARCHAR(45)'.$this->checkFieldString($column);
    }

    /**
     * Create the column definition for a integer type.
     */
    protected function typeInteger(Fluent $column)
    {
        return 'INTEGER'.$this->checkFieldNumeric($column);
    }

    /**
     * Create the column definition for a json type.
     */
    protected function typeJson(Fluent $column)
    {
        return 'CLOB(1G)'.$this->checkFieldString($column);
    }

    /**
     * Create the column definition for a json type.
     */
    protected function typeJsonb(Fluent $column)
    {
        return $this->typeJson($column);
    }

    /**
     * Create the column definition for a long text type.
     */
    protected function typeLongText(Fluent $column)
    {
        return 'CLOB(1G)'.$this->checkFieldString($column);
    }

    /**
     * Create the column definition for a MAC address type.
     */
    protected function typeMacAddress(Fluent $column)
    {
        return 'VARCHAR(17)'.$this->checkFieldString($column);
    }

    /**
     * Create the column definition for a medium integer type.
     */
    protected function typeMediumInteger(Fluent $column)
    {
        return $this->typeBigInteger($column);
    }

    /**
     * Create the column definition for a medium text type.
     */
    protected function typeMediumText(Fluent $column)
    {
        return 'CLOB(16M)'.$this->checkFieldString($column);
    }

    /**
     * Create the column definition for a set enumeration type.
     */
    protected function typeSet(Fluent $column)
    {
        throw new RuntimeException('This database driver does not support the set enumeration type.');
    }

    /**
     * Create the column definition for a small integer type.
     */
    protected function typeSmallInteger(Fluent $column)
    {
        return $this->typeInteger($column);
    }

    /**
     * Create the column definition for a string type.
     */
    protected function typeString(Fluent $column)
    {
        return "VARCHAR({$column->length})".$this->checkFieldString($column);
    }

    /**
     * Create the column definition for a text type.
     */
    protected function typeText(Fluent $column)
    {
        return 'CLOB(64K)'.$this->checkFieldString($column);
    }

    /**
     * Create the column definition for a time type.
     */
    protected function typeTime(Fluent $column)
    {
        return 'TIME'.$this->checkFieldNullable($column).$this->checkCurrentTime($column);
    }

    /**
     * Create the column definition for a timeTz type.
     */
    protected function typeTimeTz(Fluent $column)
    {
        return $this->typeTime($column);
    }

    /**
     * Create the column definition for a timestamp type.
     */
    protected function typeTimestamp(Fluent $column)
    {
        return 'TIMESTAMP'.$this->checkFieldNullable($column).$this->checkCurrentTimestamp($column);
    }

    /**
     * Create the column definition for a timestampTz type.
     */
    protected function typeTimestampTz(Fluent $column)
    {
        return $this->typeTimestamp($column);
    }

    /**
     * Create the column definition for a tiny integer type.
     */
    protected function typeTinyInteger(Fluent $column)
    {
        return 'SMALLINT'.$this->checkFieldNumeric($column);
    }

    /**
     * Create the column definition for a tiny text type.
     */
    protected function typeTinyText(Fluent $column)
    {
        return 'VARCHAR(255)'.$this->checkFieldString($column);
    }

    /**
     * Create the column definition for a json type.
     */
    protected function typeUuid(Fluent $column)
    {
        return 'CHAR(36)'.$this->checkFieldString($column);
    }

    /**
     * Create the column definition for a vector type.
     */
    protected function typeVector(Fluent $column)
    {
        throw new RuntimeException('This database driver does not support the vector type.');
    }

    /**
     * Create the column definition for a year type.
     */
    protected function typeYear(Fluent $column)
    {
        return $this->typeSmallInteger($column);
    }
}
